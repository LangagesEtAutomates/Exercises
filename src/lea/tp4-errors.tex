\ifdefined\CORRECTION
\documentclass[correction]{td}
\else
\documentclass{td}
\fi

\inputexercisepath[src/corrections/TP]{src/exercises}

\usepackage[T1]{fontenc}
\usepackage[hidelinks]{hyperref}
\usepackage{amsmath,amssymb, mathrsfs, stmaryrd}
\newcommand\eqdef{\stackrel{\text{def}}{=}}

\usepackage{algos}
\usepackage{statemachines}
\usepackage{trees}

\codeUE{XLG4IU020}
\intituleUE{Langages et Automates}
\cursus{L2 Informatique}

\author{Matthieu \textsc{Perrin}}

\logo{src/img/logoUN.png}
\institution{Nantes Université}

\typeTP[4]
\title{Gestion des erreurs avec CUP}

\hypersetup{
  pdftitle  = {Langages et Automates - TP 4 - Gestion des erreurs avec CUP},
  pdfauthor = {Matthieu Perrin},
  pdfsubject  = {TP de L2 en Langages et Automates},
  pdfkeywords = {grammaires algébriques, AST, interprétation, CUP, JFlex, récupération d'erreurs}
}

\begin{document}

\maketitle

Dans les TPs précédents, nous avons construit un analyseur lexical (JFlex),
un parseur (CUP), puis un interpréteur pour un langage algorithmique.
Jusqu'à présent, en cas d'erreur de syntaxe, CUP s'arrête rapidement,
ou affiche des messages difficiles à exploiter dans un vrai outil.
Or, un compilateur ou un interpréteur \emph{utile} doit :
\begin{itemize}
\item détecter des erreurs \emph{lexicales} et \emph{syntaxiques} ;
\item essayer de continuer l'analyse pour signaler plusieurs erreurs en une seule exécution ;
\item refuser d'exécuter un programme invalide, tout en fournissant des diagnostics clairs.
\end{itemize}

Le but de ce TP est de mettre en place une stratégie de gestion d'erreurs
\emph{simple} et \emph{systématique} :
\begin{itemize}
\item une liste d'erreurs (message + ligne) accumulée pendant l'analyse ;
\item des points de récupération (\lstinline|error|) placés à des endroits \emph{stables} de la grammaire ;
\item un flot de contrôle clair : \emph{si des erreurs existent, on n'exécute pas}.
\end{itemize}

\paragraph{Principe général (à retenir)}
Le symbole spécial \lstinline|error| de CUP n'est pas un token du lexer.
Il sert à \emph{reprendre} l'analyse après une erreur, mais il n'est efficace que si l'on
l'associe à un \emph{synchroniseur} (par exemple \lstinline|PT_VIRG|, \lstinline|ALORS|,
\lstinline|FAIRE|, \lstinline|FIN SI|, etc.).
Dans ce TP, on \emph{évite} d'utiliser \lstinline|error| à l'intérieur des expressions ;
on préfère récupérer aux frontières des instructions et des structures de contrôle.

% ==========================================================
\begin{exercice}[Mise en place : erreurs et flot de contrôle]
  \begin{question}
  \item Clonez le dépôt du TP :
    \begin{lstlisting}[gobble=6, language=bash]
      git clone https://github.com/LangagesEtAutomates/TP5-Template
    \end{lstlisting}
  \end{question}

  Le projet fourni est la solution du TP précédent, enrichie d'un début de gestion d'erreurs.
  Les fichiers principaux sont toujours :
  \lstinline|Lexer.flex|, \lstinline|Parser.cup|, \lstinline|AST.java|, \lstinline|Interpreter.java|.

  \paragraph{Représenter les erreurs}
  On utilisera une structure de données très simple :
  \begin{lstlisting}[language=Java]
    public record Error(String message, int line)
      implements Instruction, Expression {}
  \end{lstlisting}
  et une liste :
  \begin{lstlisting}[language=Java]
    public final List<Error> errors = new ArrayList<>();
  \end{lstlisting}

  \paragraph{Récupération grossière au niveau instruction}
  Le parseur fourni contient déjà une règle de récupération au niveau des commandes :
  \begin{lstlisting}
    commande ::=
        ...
      | error PT_VIRG
        {: var e = new Error("erreur dans les instructions", @1.left);
           errors.add(e);
           RESULT = e;
        :}
      ;
  \end{lstlisting}

  \begin{question}
  \item Compilez et exécutez l'outil sur le programme suivant :
    \begin{lstlisting}
      algorithme
        x <- 1;
        y <- x + ;
        y <- x + ;
        écrire(y * 3);
      fin
    \end{lstlisting}
    Combien d'erreurs sont détectées ? Le parseur construit-il encore un AST ?
    Le programme est-il exécuté ?

  \item Dans \lstinline|Interpreter.java|, identifiez l'endroit où l'analyse lexicale et syntaxique
    est déclenchée.
    Expliquez pourquoi \lstinline|parser.parse()| ne retourne pas directement un \lstinline|Program|,
    et comment on récupère l'objet construit par la règle de départ.

  \item Le but de ce TP est de centraliser l'affichage des erreurs \emph{à la fin} de l'analyse.
    Modifiez le code pour que \emph{seule} la méthode principale affiche la liste des erreurs,
    et que le parseur/lexer n'affiche rien directement sur la sortie standard.

  \item Vérifiez que l'exécution suit bien le flot suivant :
    \[
      \text{lexer \& parser} \longrightarrow
      \begin{cases}
        \text{si } errors = \varnothing : \text{exécuter} \\
        \text{sinon : afficher les erreurs et quitter}
      \end{cases}
    \]
  \end{question}

\end{exercice}

% ==========================================================
\begin{exercice}[Récupérer une erreur dans une conditionnelle (guidé)]
  Dans une conditionnelle, une erreur dans l'expression de garde ne doit pas forcément
  détruire toute la structure \texttt{si ... alors ... sinon ... fin si}.
  Le principe est d'introduire un point de récupération \emph{local} sur le synchroniseur \lstinline|ALORS|,
  puis un filet de sécurité \emph{global} sur \lstinline|FIN SI|.

  On souhaite réorganiser la grammaire de la conditionnelle selon le schéma suivant :
  \begin{lstlisting}
    conditionnelle ::=
        SI cond_si:cond sequence:iftrue SINON sequence:iffalse FIN SI
      | error FIN SI
      ;

    cond_si ::=
        expression:e ALORS
      | error ALORS
      ;
  \end{lstlisting}

  \begin{question}
  \item Dans \lstinline|Parser.cup|, introduisez un nouveau non-terminal
    \lstinline|conditionnelle|, puis modifiez \lstinline|commande| pour l'utiliser :
    \begin{lstlisting}
      commande ::=
          ...
        | conditionnelle:c {: RESULT = c; :}
        | error PT_VIRG    {: ... :}
        ;
    \end{lstlisting}

  \item Définissez le non-terminal \lstinline|cond_si| avec \emph{deux} alternatives :
    \begin{itemize}
      \item \lstinline|expression ALORS| : cas nominal ;
      \item \lstinline|error ALORS| : récupération locale, qui \emph{consomme} \lstinline|ALORS|.
    \end{itemize}
    Dans les deux cas, \lstinline|cond_si| doit produire une \lstinline|Expression|.

  \item Ajoutez ensuite la récupération globale :
    \begin{lstlisting}
      | error FIN SI {: ... :}
    \end{lstlisting}
    À quoi sert ce filet de sécurité ? Donnez un exemple d'entrée pour laquelle
    la récupération locale \lstinline|error ALORS| ne suffit pas.

  \item Testez votre implémentation sur les entrées suivantes et comparez les comportements :
    \begin{enumerate}
    \item erreur dans la condition mais \lstinline|ALORS| présent :
      \begin{lstlisting}
        si x + alors
          écrire(1);
        sinon
          écrire(2);
        fin si
      \end{lstlisting}
    \item structure trop cassée (par exemple \lstinline|ALORS| absent) :
      \begin{lstlisting}
        si x < 3
          écrire(1);
        sinon
          écrire(2);
        fin si
      \end{lstlisting}
    \end{enumerate}
    Dans chaque cas, précisez si le corps de la conditionnelle est encore analysé
    et si les instructions suivantes au programme restent détectées.
  \end{question}

  \paragraph{Même travail pour \texttt{tant que}}
  \begin{question}
  \item Appliquez exactement la même stratégie à la boucle :
    \begin{lstlisting}
      tant que <expression> faire
        <sequence>
      fin tant que
    \end{lstlisting}
    Vous introduirez un non-terminal \lstinline|cond_tq| qui consomme \lstinline|FAIRE|,
    ainsi qu'un filet de sécurité sur \lstinline|FIN TANT QUE|.
  \end{question}

\end{exercice}

% ==========================================================
\begin{exercice}[Extension : boucle \texttt{pour} et gestion d'erreurs (autonome)]
  Le but de cet exercice est d'ajouter une nouvelle structure de contrôle au langage :
  \begin{lstlisting}
    pour i de <expression> a <expression> faire
      <sequence>
    fin pour
  \end{lstlisting}
  où \lstinline|i| est un identifiant, et les deux expressions décrivent une borne inférieure et supérieure.
  L'interpréteur exécutera le corps pour toutes les valeurs entières de \lstinline|i|
  entre les deux bornes (incluses). Par exemple :
  \begin{lstlisting}
    pour i de 1 a 3 faire
      écrire(i);
    fin pour
  \end{lstlisting}
  doit afficher \texttt{1}, puis \texttt{2}, puis \texttt{3}.

  \paragraph{Objectif principal : appliquer la stratégie d'erreurs}
  Cette nouvelle structure doit être robuste aux erreurs, selon le même patron que \lstinline|si| et \lstinline|tant que| :
  \begin{itemize}
  \item récupération \emph{locale} sur le synchroniseur \lstinline|FAIRE| (si une borne est invalide) ;
  \item filet de sécurité \emph{global} sur \lstinline|FIN POUR| (si la structure est trop cassée).
  \end{itemize}

  \begin{question}
  \item Étendez le lexer pour reconnaître les nouveaux mots-clés \lstinline|pour|, \lstinline|de|, \lstinline|a|, et le terminal
    \lstinline|FIN POUR| (selon votre choix de tokenisation : \lstinline|FIN| suivi de \lstinline|POUR|, ou un unique terminal).

  \item Étendez l'AST en ajoutant une instruction \lstinline|For|. Vous êtes libres du choix exact,
    mais la structure doit contenir :
    \begin{itemize}
    \item le nom de la variable de boucle ;
    \item les deux expressions de bornes ;
    \item le corps de boucle.
    \end{itemize}

  \item Implémentez l'exécution dans l'interpréteur.

  \item \textbf{(Point clé)} Modifiez la grammaire CUP pour ajouter :
    \begin{itemize}
    \item une règle nominale pour la boucle \lstinline|pour| ;
    \item une récupération \emph{locale} sur \lstinline|FAIRE| (par exemple via un non-terminal \lstinline|bornes_pour|) ;
    \item une récupération \emph{globale} sur \lstinline|FIN POUR|.
    \end{itemize}
    Vous veillerez à ne pas \emph{dupliquer} les mots-clés (\lstinline|FAIRE| ne doit être consommé qu'une seule fois).

  \item Testez votre gestion d'erreurs sur des programmes contenant :
    \begin{itemize}
    \item une borne invalide mais \lstinline|FAIRE| présent ;
    \item une structure \texttt{pour} trop cassée, qui doit déclencher la récupération globale ;
    \item plusieurs erreurs dans le même programme, y compris après une boucle \texttt{pour}.
    \end{itemize}
  \end{question}

\end{exercice}

\end{document}
