\ifdefined\CORRECTION
\documentclass[correction]{td}
\else
\documentclass{td}
\fi

\inputexercisepath[src/corrections/TP]{src/exercises}

\usepackage[T1]{fontenc}
\usepackage[hidelinks]{hyperref}
\usepackage{amsmath,amssymb, mathrsfs, stmaryrd}
\newcommand\eqdef{\stackrel{\text{def}}{=}}

\usepackage{algos}
\usepackage{statemachines}
\usepackage{trees}

\codeUE{XLG4IU020}
\intituleUE{Langages et Automates}
\cursus{L2 Informatique}

\author{Matthieu \textsc{Perrin}}

\logo{src/img/logoUN.png}
\institution{Nantes Université}

\typeTP[2]
\title{Introduction à CUP}

\hypersetup{
  pdftitle  = {Langages et Automates - TP 2 - Introduction à CUP},
  pdfauthor = {Matthieu Perrin},
  pdfsubject  = {TP de L2 en Langages et Automates},
  pdfkeywords = {grammaires algébriques, analyse syntaxique, CUP}
}

\begin{document}

\maketitle

CUP (\emph{Constructor of Useful Parsers}) est un générateur d'analyseurs
syntaxiques pour Java, conceptuellement proche de Bison ou Yacc.
Il prend en entrée un fichier décrivant une grammaire algébrique
compatible avec les analyseurs ascendants (bottom-up) de type LR(1)
(\emph{Left-to-right scanning, constructing a Rightmost derivation in reverse}),
et génère une classe Java \texttt{parser} capable d'analyser un flux de tokens.

CUP est généralement utilisé en combinaison avec JFlex : JFlex découpe
le flux de caractères en tokens, et l'analyseur CUP consomme ces tokens
pour vérifier qu'ils suivent la grammaire et éventuellement calculer
une valeur (évaluation d'expression, construction d'AST, etc.).

Dans ce TP, nous apprendrons à écrire un fichier \texttt{.cup} décrivant une grammaire,
générer un analyseur Java à l'aide de CUP,
et associer des actions sémantiques aux règles de grammaire pour construire des valeurs.

\begin{exercice}[Mise en place]

  Un exemple de programme utilisant \emph{CUP} est fourni dans le dépôt.
  Il servira de base aux exercices suivants. Nous allons commencer par le
  télécharger, générer les analyseurs et compiler le projet.

  \begin{question}
  \item Clonez le dépôt :
    \begin{lstlisting}[gobble=4, language=bash]
      git clone https://github.com/LangagesEtAutomates/TP-CUP-Template
      cd TP-CUP-Template
    \end{lstlisting}

  \item Générez le lexer JFlex, l'analyseur CUP et compilez le projet :
    \begin{lstlisting}[gobble=4, language=bash]
      ant compile
    \end{lstlisting}

  \item Expliquez chaque ligne écrite par la génération des analyseurs dans le terminal.

  \item Vérifiez que CUP a bien généré des fichiers
    \lstinline{build/calculator/parser.java} et 
    \lstinline{build/calculator/Sym.java}.

  \item Lancez le programme d'exemple :
    \begin{lstlisting}[gobble=4, language=bash]
      java -cp "build:lib/*" calculator.Main
    \end{lstlisting}

    Testez-le en saisissant quelques expressions dans le terminal : 
    \begin{lstlisting}
      42       // Sortie attendue : 42
      1+2      // Sortie attendue : 3
      1+2+3+4  // Sortie attendue : 10
      1+2*3    // Erreur
    \end{lstlisting}
  \end{question}

  \paragraph{Architecture du programme}
  L'entrée du programme est la méthode \lstinline|Main.main|, qui
  crée, pour chaque ligne lue sur l'entrée standard, un \lstinline|lexer|
  de type \lstinline|Lexer| (généré par JFlex)
  et un \lstinline|parser| de type \lstinline|Parser| (généré par CUP).

  Les tokens utilisés par JFlex et CUP pour communiquer sont des objets de type
  \lstinline|java_cup.runtime.Symbol|. Chaque appel à \lstinline|lexer.yylex()|
  retourne un tel objet, contenant à la fois le type du token (par exemple
  \lstinline|sym.NUMBER| ou \lstinline|sym.PLUS|) et, éventuellement,
  une valeur associée (comme un entier pour les nombres). Le parseur CUP
  (\lstinline|Parser.parse()|) consomme ces \lstinline|Symbol| successifs
  pour appliquer les règles de la grammaire et calculer le résultat final.

  \begin{question}
  \item L'analyseur lexical est déjà donné dans le fichier \lstinline{src/calculator/lexer.flex}.
    Lisez le fichier et identifiez les motifs reconnus. 
  \end{question}
  
  La méthode \lstinline|parser.parse()| se charge ensuite d'appeler
  autant de fois \lstinline|lexer.yylex()| que nécessaire pour analyser la
  ligne et calculer le résultat de l'expression.

  L'architecture du programme est résumée par le diagramme de séquence suivant :
  \begin{center}
    \begin{tikzpicture}[x=50mm, y=6mm]
      \draw (1,0) node[draw] (Lexer)  {\texttt{Lexer}}        edge[dashed, ->] +(0,-11);
      \draw (2,0) node[draw] (Parser) {\texttt{Parser}}       edge[dashed, ->] +(0,-11);
      \draw (3,0) node[draw] (Main)   {\texttt{Main}}         edge[dashed, ->] +(0,-11);

      \node[draw, fill=black!10, minimum width=3mm, fit={(Main|-0,-1)(Main|-0,-10)},    inner sep=0pt, outer sep=0pt] (main)  {};
      \node[draw, fill=black!10, minimum width=3mm, fit={(Parser|-0,-2)(Parser|-0,-9)}, inner sep=0pt, outer sep=0pt] (parse) {};
      \node[draw, fill=black!10, minimum width=3mm, fit={(Lexer|-0,-3)(Lexer|-0,-4)},   inner sep=0pt, outer sep=0pt] (yylex1) {};
      \node[draw, fill=black!10, minimum width=3mm, fit={(Lexer|-0,-5)(Lexer|-0,-6)},   inner sep=0pt, outer sep=0pt] (yylex2) {};
      \node[draw, fill=black!10, minimum width=3mm, fit={(Lexer|-0,-7)(Lexer|-0,-8)},   inner sep=0pt, outer sep=0pt] (yylex3) {};
      
      \path[-latex] (main.west |- parse.north)     edge node[above]{\texttt{parse()}}             (parse.north east) {};
      \path[-latex] (parse.west |- yylex1.north)   edge node[above]{\texttt{yylex()}}             (yylex1.north east) {};
      \path[-latex] (yylex1.south east)            edge node[above]{\texttt{Symbol(NUMBER, 1)}} (parse.west |- yylex1.south) {};
      \path[-latex] (parse.west |- yylex2.north)   edge node[above]{\texttt{yylex()}}             (yylex2.north east) {};
      \path[-latex] (yylex2.south east)            edge node[above]{\texttt{Symbol(PLUS)}}      (parse.west |- yylex2.south) {};
      \path[-latex] (parse.west |- yylex3.north)   edge node[above]{\texttt{yylex()}}             (yylex3.north east) {};
      \path[-latex] (yylex3.south east)            edge node[above]{\texttt{Symbol(NUMBER, 2)}} (parse.west |- yylex3.south) {};
      \path[-latex] (parse.south east)             edge node[above]{\texttt{3}}                   (main.west |- parse.south) {};
    \end{tikzpicture}
  \end{center}
  
  \paragraph{Structure d'un fichier CUP}
  La première partie du fichier \emph{CUP} contient du code Java
  qui sera recopié tel quel dans le fichier généré.
  On y place généralement la déclaration de package, les \emph{imports}
  et d'éventuelles déclarations de variables, classes utilitaires
  ou méthodes employées dans les actions sémantiques.
  
  La deuxième partie regroupe les déclarations de \emph{terminaux} et de
  \emph{non-terminaux}. On y trouve trois formes courantes :
  \begin{itemize}
  \item \lstinline|terminal PLUS, MINUS;| déclare les symboles terminaux
    \lstinline|PLUS| et \lstinline|MINUS|.
    Les terminaux définissent l'alphabet de la grammaire et
    correspondent aux tokens produits par le lexer.
    CUP génère automatiquement un fichier \lstinline|build/calculator/sym.java|
    qui associe un entier unique à chaque symbole terminal.

  \item \lstinline|terminal Integer NUMBER;| déclare le terminal typé
    \lstinline|NUMBER| : les tokens portant ce symbole transportent
    une valeur de type \lstinline|Integer| dans le champ \lstinline|value|
    de \lstinline|java_cup.runtime.Symbol|.

  \item \lstinline|non terminal Integer expr;| déclare le non-terminal
    \lstinline|expr| en précisant qu'il produit une valeur de type
    \lstinline|Integer|.
  \end{itemize}

  La troisième partie contient les règles de la grammaire.
  Chaque règle associe un non-terminal à une ou plusieurs productions, et
  peut inclure une \emph{action sémantique} : un bloc de code Java entre
  \lstinline|{:| et \lstinline|:}| qui sera exécuté lorsque la production
  est réduite. La structure générale est de la forme :\\
  \texttt{non-terminal ::= production1 \{ action1; \} | production2 \{ action2; \} ;}
  
  L'exemple ci-dessous correspond à la grammaire
  $S \rightarrow N \mid S + N$, où $N$ représente un entier :
  \begin{lstlisting}
    expr ::= NUMBER:n                     {: RESULT = n; :}
    |        expr:left PLUS NUMBER:right  {: RESULT = left + right; :}
    ;
  \end{lstlisting}

  Dans une action CUP, la variable \texttt{RESULT} représente la valeur
  sémantique du non-terminal dont on applique la règle.


  Ici, \lstinline|RESULT| représente la valeur associée au non-terminal
  \lstinline|expr| pour la règle en cours d'application.
  Son type est \texttt{Integer}, conformément à la déclaration de \lstinline|expr|.
  Après chaque symbole, \texttt{:nom} permet de donner un nom
  à sa valeur sémantique, afin de pouvoir l'utiliser dans les actions.

  \begin{question}
  \item Ajoutez la ligne suivante dans la définition de \lstinline|expr|
    pour gérer les parenthèses selon la règle $S \rightarrow (S)$ :
    \begin{lstlisting}
      | LPAREN expr:e RPAREN {: RESULT = e; :}
    \end{lstlisting}

  \item Testez le programme avec les expressions suivantes,
    et expliquez les résultats en dessinant les arbres de dérivation :
    \begin{lstlisting}
      (1+2)+4  // Sortie attendue : 7
      4+(1+2)  // Erreur de syntaxe
    \end{lstlisting}

  \item Modifiez le fichier CUP de la façon suivante, puis testez à nouveau votre programme avec les entrées ci-dessus :
    \begin{lstlisting}
      expr ::= expr:left PLUS term:right  {: RESULT = left + right; :}
      |        term:t                     {: RESULT = t; :}
      ;
      term ::= NUMBER:n             {: RESULT = n; :}
      |        LPAREN expr:e RPAREN {: RESULT = e; :}
      ;
    \end{lstlisting}
    La grammaire reconnue est maintenant la suivante :
    $$
    \left\{
    \begin{array}{rcl}
      S &\rightarrow& S + T \mid T \\
      T &\rightarrow& N \mid (S)
    \end{array}
    \right.
    $$

  \item Modifiez les actions associées aux règles de la grammaire
    pour calculer le nombre maximal de parenthèses imbriquées dans
    l'expression. Par exemple, l'expression \verb|(((0))+0)+((0))|
    devra retourner \verb|3|, car le premier \verb|0| est entouré
    de trois niveaux de parenthèses.
  \end{question}
  
\end{exercice}

\begin{exercice}[Grammaire de la calculatrice]

  On souhaite maintenant définir une grammaire complète pour des expressions
  arithmétiques avec priorités usuelles des opérateurs.

  \begin{question}

  \item Modifiez le fichier \texttt{Parser.cup} pour implémenter la grammaire suivante.  
    $$
    \begin{array}{ll}
      G = \langle & \{\textsc{number}, +, *, (, )\},
      \{\mathit{expr}, \mathit{somme}, \mathit{produit}, \mathit{terme}\},
      \mathit{expr},\\
      & \left\{ \begin{array}{lllll}
        \mathit{expr}    &\rightarrow& \mathit{somme} \\
        \mathit{somme}   &\rightarrow& \mathit{somme} + \mathit{produit} &\mid& \mathit{produit} \\
        \mathit{produit} &\rightarrow& \mathit{produit} * \mathit{terme} &\mid& \mathit{terme} \\
        \mathit{terme} &\rightarrow& (\;\mathit{somme}\;) &\mid& \textsc{number} \\
      \end{array} \right\}\;\rangle
    \end{array}
    $$
    Pensez à déclarer les non-terminaux, de type \lstinline|Integer|, dans la section des déclarations.

  \item Ajoutez des actions sémantiques pour que chaque non-terminal retourne
    la valeur de l'expression correspondante.
    Le non-terminal \lstinline|expr| doit renvoyer le résultat final affiché par \texttt{Main}.

  \item Ajoutez la \emph{soustraction}.
    Votre grammaire doit respecter les priorités usuelles :
    \begin{itemize}
    \item \texttt{*} est plus prioritaire que \texttt{+} et \texttt{-} ;
    \item \texttt{+} et \texttt{-} sont associatives à gauche (par exemple $1-2-3 = (1-2)-3$).
    \end{itemize}

  \item Ajoutez l'opérateur unaire \texttt{-} pour les nombres et les parenthèses.
    L'opposé unaire doit être plus prioritaire que la multiplication,
    mais moins que les parenthèses.
    Par exemple, l'expression \verb|-(2*-3)| doit être évaluée à \verb|6|.
  \end{question}

\end{exercice}

\begin{exercice}[Support des booléens]

  On souhaite maintenant ajouter des opérations booléennes à notre calculatrice.
  La valeur booléenne \texttt{faux} sera représentée par l'entier $0$,
  et la valeur booléenne \texttt{vrai} sera représentée par n'importe quel entier non nul, par défaut $1$.
  
  \begin{question}

  \item Modifiez le lexer pour reconnaître
    les opérateurs \lstinline|ou|, \lstinline|et|, \lstinline|non| et \lstinline|=|.
    L’opérateur \lstinline|=| est ici un \emph{test d’égalité} :
    il devra produire \texttt{vrai} si les deux opérandes sont égaux, et \texttt{faux} sinon.
    Pensez à déclarer les terminaux correspondants dans le parser.

  \item Ajoutez à votre calculatrice des règles pour reconnaître les opérateurs booléens.
    La priorité des opérateurs (de la moins prioritaire à la plus prioritaire) est la suivante :
    \lstinline|ou|, puis \lstinline|et|, puis \lstinline|non|, puis \lstinline|=|,
    puis enfin les opérateurs arithmétiques sur les entiers.
    Vous pouvez pour cela étendre la grammaire précédente en ajoutant des niveaux
    intermédiaires.

  \item Ajoutez les actions sémantiques correspondant à chaque opérateur.
    
  \end{question}

\end{exercice}

\end{document}
