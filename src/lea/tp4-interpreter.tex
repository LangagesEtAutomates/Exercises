\ifdefined\CORRECTION
\documentclass[correction]{td}
\else
\documentclass{td}
\fi

\inputexercisepath[src/corrections/TP]{src/exercises}

\usepackage[T1]{fontenc}
\usepackage[hidelinks]{hyperref}
\usepackage{amsmath,amssymb, mathrsfs, stmaryrd}
\newcommand\eqdef{\stackrel{\text{def}}{=}}

\usepackage{algos}
\usepackage{statemachines}
\usepackage{trees}

\codeUE{XLG4IU020}
\intituleUE{Langages et Automates}
\cursus{L2 Informatique}

\author{Matthieu \textsc{Perrin}}

\logo{src/img/logoUN.png}
\institution{Nantes Université}

\typeTP[4]
\title{Interpréteur pour le langage algorithmique}

\hypersetup{
  pdftitle  = {Langages et Automates - TP 4 - Interpréteur pour le langage algorithmique},
  pdfauthor = {Matthieu Perrin},
  pdfsubject  = {TP de L2 en Langages et Automates},
  pdfkeywords = {grammaires algébriques, AST, interprétation, CUP, JFlex}
}

\begin{document}

\maketitle

Dans les TPs précédents, nous avons appris à utiliser JFlex et CUP pour construire
un analyseur lexical et syntaxique pour une calculatrice.
Le parseur CUP construisait directement une \emph{valeur} entière,
en appliquant des actions sémantiques associées aux règles de la grammaire.

Le but de ce TP est de construire un \emph{interpréteur} en Java pour le langage algorithmique
utilisé dans les cours d'algorithmique et de programmation, qui lit le code source d'un algorithme
et en simule l'exécution.

Dans un programme, les blocs de code peuvent être exécutés 0, 1 ou plusieurs fois en fonction des
structures de contrôle utilisées. Il n'est donc pas possible d'interpréter le programme directement
pendant l'analyse syntaxique. Dans ce TP, le parseur construira donc un \emph{arbre de syntaxe abstraite}
(\emph{AST}, pour \emph{Abstract Syntax Tree}), qui sera ensuite exploité par l'interpréteur.

\begin{exercice}[Mise en place de l'interpréteur]
  
  \begin{question}
  \item Clonez le dépôt du TP :
    \begin{lstlisting}[gobble=4, language=bash]
      git clone https://github.com/LangagesEtAutomates/lea-tp4-interpreter
    \end{lstlisting}
  \end{question}

  La compilation et l'exécution de l'interpréteur sont similaires aux TPs précédents.
  
  \paragraph{Structure du code fourni}

  Avant d'étendre le langage, il est important de comprendre la structure du projet.
  Celui-ci contient quatre fichiers principaux :

  \begin{itemize}
  \item un fichier JFlex \lstinline|Lexer.flex| pour l'analyse lexicale ;
  \item un fichier CUP \lstinline|Parser.cup| pour l'analyse syntaxique ;
  \item une hiérarchie de types représentant l'arbre de syntaxe abstraite (AST)
    dans \lstinline|AST.java| ;
  \item un programme principal dans \lstinline|Main.java|.
  \item un interpréteur dans \lstinline|Interpreter.java|.
  \item un outil de gestion des erreurs dans \lstinline|Reporter.java|.
  \end{itemize}

  L'analyseur lexical découpe le texte en \emph{tokens}
  (\lstinline|ID|, \lstinline|LITERAL|, \lstinline|PLUS|, \lstinline|ECRIRE|, etc.).
  L'analyseur syntaxique CUP reçoit ces tokens et construit un \emph{AST}, c'est-à-dire
  une représentation arborescente du programme.
  Tous les nœuds de l'AST implémentent l'interface \lstinline|AST|.
  Ils se répartissent en deux grandes familles :

  \begin{itemize}

  \item les \emph{expressions}, qui implémentent \lstinline|Expression|.
    Par exemple, l'expression \lstinline|1 + x| est traduite en :\\
    \hspace*{1cm}\lstinline|Sum(Literal(1), Identifier("x"))|.\\
    Les formes d'expressions disponibles dans la version fournie correspondent
    aux expressions arithmétiques et booléennes prises en charge dans
    le TP d'introduction à CUP.

  \item les \emph{instructions}, qui implémentent \lstinline|Instruction|.
    Par exemple, l'instruction \lstinline|x <- 1;| devient :\\
    \hspace*{1cm}\lstinline|Assignment(Identifier("x"), Literal(1))|.\\[1mm]
    Dans la version fournie, trois types d'instructions sont reconnus :
    \begin{itemize}
    \item les \emph{affectations} \lstinline|x <- expression;| ;
    \item les \emph{instructions d'écriture} \lstinline|écrire(expr);| ;
    \item les \emph{séquences d'instructions} (plusieurs commandes successives). 
    \end{itemize}

  \end{itemize}

  La hiérarchie des types fournis dans \lstinline|AST.java| est illustrée ci-dessous :

  \begin{center}
    \begin{tikzpicture}[tree, x=20mm, y=8mm]
      \tree{\lstinline|AST|}{
        \tree{\lstinline|Instruction|}{
          \tree{\lstinline|Sequence|}{}
          \tree{\lstinline|Assignment|}{}
          \tree{\lstinline|Write|}{}
        }
        \tree{\lstinline|Expression|}{
          \tree{\lstinline|Identifier|}{}
          \tree{\lstinline|Literal|}{}
          \tree{\lstinline|Sum|}{}
          \tree{...}{}
        }
      }
    \end{tikzpicture}
  \end{center}

  Ainsi, le programme suivant est déjà entièrement reconnu et correctement analysé :

  \begin{lstlisting}
    x <- 1;
    y <- x + 2;
    écrire(y*3);
  \end{lstlisting}

  La sortie de CUP pour ce programme est l'AST suivant :

  \begin{center}
    \begin{tikzpicture}[tree, x=20mm, y=8mm]
      \tree{\lstinline|Sequence|}{
        \tree{\lstinline|Assignment|}{
          \tree{\lstinline|Identifier|}{\tree{$x$}{}}
          \tree{\lstinline|Literal|}{\tree{$1$}{}}
        }
        \tree{\lstinline|Assignment|}{
          \tree{\lstinline|Identifier|}{\tree{$y$}{}}
          \tree{\lstinline|Sum|}{
            \tree{\lstinline|Identifier|}{\tree{$x$}{}}
            \tree{\lstinline|Literal|}{\tree{$2$}{}}
          }
        }
        \tree{\lstinline|Write|}{
          \tree{\lstinline|Product|}{
            \tree{\lstinline|Identifier|}{\tree{$y$}{}}
            \tree{\lstinline|Literal|}{\tree{$3$}{}}
          }
        }
      }
    \end{tikzpicture}
  \end{center}

  \paragraph{Fonctionnement de l'interpréteur}

  Le fichier \lstinline|Interpreter.java| contient une classe capable d'exécuter
  un AST en simulant une machine abstraite :

  \begin{itemize}
  \item la \emph{mémoire} (valeur associée à chaque variable)
    est représentée par une table \lstinline|Map<String, Integer> variables|
    qui associe un entier à chaque nom de variable initialisée. 
  \item les instructions sont exécutées récursivement par
    la méthode \lstinline|interpret| ;
  \item les expressions sont évaluées récursivement par la méthode
    \lstinline|eval|.
  \end{itemize}

  Par exemple, l'interprétation de la commande
  \lstinline|Assignment(Identifier("x"), Sum(Literal(1), Literal(2)))|
  entraîne trois appels à \lstinline|eval| (sur \lstinline|Sum|, puis sur
  chacun des deux \lstinline|Literal|), puis l'écriture de la valeur $3$
  dans \lstinline|variables["x"]|.

  Cette architecture sera étendue dans les exercices suivants pour permettre
  la gestion d'autres structures de contrôle.

  \begin{question}
  \item Que se passe-t-il lorsqu'on évalue un identifiant qui n'a pas encore
    été initialisé ? Proposez un autre choix raisonnable possible. 
  \item Dessinez l'AST produit par le parser pour le programme suivant :
    \begin{lstlisting}
      x <- 4;
      écrire(x);
    \end{lstlisting}
  \item Énumérez la suite d'appels aux méthodes \lstinline|interpret|
    et \lstinline|eval| lors de l'exécution du programme de la question précédente, ainsi que leurs
    valeurs de retour.
  \end{question}


  \paragraph{Gestion des erreurs syntaxiques}

  Le parseur CUP fourni ne se contente pas de signaler une erreur et de s'arrêter.
  Il contient une règle de \emph{récupération d'erreur} permettant de reprendre
  l'analyse après une instruction incorrecte.

  Dans la grammaire des commandes, on trouve la règle suivante :
  \begin{lstlisting}
    | error PT_VIRG
    { reporter.error(Reporter.Phase.PARSER, -1, -1,
      "erreur dans les instructions");
      RESULT = new ErrorNode(); }
  \end{lstlisting}

  Le symbole spécial \lstinline|error| est fourni par CUP.
  Il permet de reconnaître une séquence de tokens invalide et de
  reprendre l'analyse à partir d'un \emph{symbole de synchronisation},
  ici le point-virgule \lstinline|PT_VIRG|.

  Lorsque cette règle est utilisée, un n\oe ud \lstinline|ErrorNode|
  est inséré dans l'AST, ce qui permet de poursuivre l'analyse
  (et éventuellement l'interprétation) du reste du programme.
  
  \begin{question}
  \item Testez l'analyse syntaxique sur les programmes ci-dessous et indiquez à quel endroit l'analyse reprend.

    \begin{minipage}{.25\textwidth}
    \begin{lstlisting}
      algorithme
      variables
        x : entier;
      début
        x <- 1 + ;
        écrire(0);
      fin
    \end{lstlisting}
    \end{minipage}%
    \begin{minipage}{.25\textwidth}
    \begin{lstlisting}
      algorithme
      variables
        x : entier;
      début
        x <- 0;
        écrire((x);
        écrire(1);
      fin
    \end{lstlisting}
    \end{minipage}%
    \begin{minipage}{.4\textwidth}
    \begin{lstlisting}
      algorithme
      début
        si 1 + alors 
          écrire(0);
        sinon 
          écrire(1);
        fin si
        écrire(2);
      fin
    \end{lstlisting}
    \end{minipage}%

  \item
  La règle précédente permet de récupérer des erreurs au niveau des \emph{instructions},
  en sautant jusqu'au point-virgule.  
  On souhaite maintenant affiner la récupération d'erreurs pour les
  conditionnelles.

  \begin{itemize}

  \item Modifiez la grammaire afin de détecter une erreur située
    à l'intérieur d'une conditionnelle, tout en permettant de
    reprendre l'analyse au mot-clé \lstinline|fin si|.

  \item Modifiez également la grammaire pour détecter une erreur
    dans la \emph{condition} du \lstinline|si|, en synchronisant sur
    le mot-clé \lstinline|alors|.
    
  \item Dans les deux cas, une erreur devra être signalée via
    \lstinline|reporter.error(...)| et un n\oe ud \lstinline|ErrorNode|
      devra être inséré dans l'AST afin de permettre la poursuite de l'analyse.
  \end{itemize}

  Vérifiez votre implémentation sur les exemples suivants :
  
  \begin{minipage}{.4\textwidth}
    \begin{lstlisting}
      algorithme
      début
        si 1 + alors 
          écrire(0);
        sinon 
          écrire(1);
        fin si
        écrire(2);
      fin
    \end{lstlisting}
  \end{minipage}%
  \begin{minipage}{.4\textwidth}
    \begin{lstlisting}
      algorithme
      début
        si 1 + alors 
          écrire(0)
        sinon 
          écrire(1)
        fin si
      fin
    \end{lstlisting}
  \end{minipage}%
  \end{question}

\end{exercice}


\begin{exercice}[Gestion des boucles]

  Le but de cet exercice est d'ajouter des structures de boucle au langage.
  
  On commence par ajouter une boucle \lstinline|pour|
  permettant d'itérer une variable entière entre deux bornes, avec un pas optionnel.
  La syntaxe de la boucle est la suivante :
  \begin{lstlisting}
    pour i de debut à fin pas p faire
      corps
    fin pour
  \end{lstlisting}
  où \lstinline|pas p| est optionnel.

  \begin{question}

  \item Modifiez le lexer JFlex afin d'ajouter les nouveaux mots-clés
    \lstinline|pour|, \lstinline|de|, \lstinline|à| et \lstinline|pas|.

  \item Modifiez le parseur CUP afin d'ajouter une nouvelle commande \lstinline|pour| à la grammaire.
    Vous êtes libre de la manière dont vous factorisez les règles, mais votre grammaire doit
    gérer le caractère optionnel de \lstinline|pas|.

  \item Étendez l'AST avec un nouveau n\oe ud d'instruction, par exemple :
    \begin{lstlisting}
      For(Identifier id, Expression start, Expression end,
          Optional<Expression> step, Sequence body).
    \end{lstlisting}

  \item Modifiez l'interpréteur afin de prendre en compte la boucle \lstinline|pour|.
    Votre implémentation doit respecter la sémantique attendue :
    \begin{itemize}
    \item La variable d'itération (ici \lstinline|i|) est une variable du programme,
      qui reçoit la valeur courante à chaque itération.
    \item La boucle s'exécute tant que la valeur courante n'a pas dépassé la borne :
      \lstinline|i <= fin| si le pas est positif, et \lstinline|i >= fin| si le pas est négatif.
    \item Les expressions \lstinline|debut|, \lstinline|fin| et \lstinline|p| ne doivent être
      évaluées \emph{qu'une seule fois}, avant la première itération.
    \item Si le pas est omis, alors il vaut \lstinline|1| si \lstinline|debut < fin|, et \lstinline|-1| sinon.
    \item On supposera dans ce TP que le pas n'est jamais nul.
    \end{itemize}

  \item Testez votre programme avec les exemples suivants :

    \begin{minipage}{.27\textwidth}
  \begin{lstlisting}
    pour i de 1 à 4 faire
      écrire(i);
    fin pour
    // affiche : 1 2 3 4
  \end{lstlisting}
  \end{minipage}%
  \begin{minipage}{.27\textwidth}
  \begin{lstlisting}
    pour i de 4 à 1 faire
      écrire(i);
    fin pour
    // affiche : 4 3 2 1
  \end{lstlisting}
  \end{minipage}%
  \begin{minipage}{.38\textwidth}
  \begin{lstlisting}
    n<-10;
    pour i de 0 à n pas 3 faire
      n<-n+1;
      écrire(i);
    fin pour
    // affiche : 0 3 6 9
  \end{lstlisting}
  \end{minipage}%


  \item Ajoutez une structure de boucle \texttt{tant que} au langage, de la forme :
    \begin{lstlisting}
      tant que <expression> faire
        <sequence>
      fin tant que
    \end{lstlisting}
    Votre construction devra permettre d'exécuter la séquence tant que
    la condition est différente de \texttt{0}.
    Testez votre implémentation avec le programme suivant :
    \begin{lstlisting}
      x <- 0;
      tant que x < 5 faire
        écrire(x);
        x <- x + 1;
      fin tant que
    \end{lstlisting}
  
  \end{question}

\end{exercice}

\end{document}
