\ifdefined\CORRECTION
\documentclass[correction]{td}
\else
\documentclass{td}
\fi

\inputexercisepath[src/corrections/TP]{src/exercises}

\usepackage[T1]{fontenc}
\usepackage[hidelinks]{hyperref}
\usepackage{amsmath,amssymb, mathrsfs, stmaryrd}
\newcommand\eqdef{\stackrel{\text{def}}{=}}

\usepackage{algos}
\usepackage{statemachines}
\usepackage{trees}

\codeUE{XLG4IU020}
\intituleUE{Langages et Automates}
\cursus{L2 Informatique}

\author{Matthieu \textsc{Perrin}}

\logo{src/img/logoUN.png}
\institution{Nantes Université}

\typeTP[5]
\title{Analyse statique de programmes}

\hypersetup{
  pdftitle  = {Langages et Automates - TP 5 - Analyse statique de programmes},
  pdfauthor = {Matthieu Perrin},
  pdfsubject  = {TP de L2 en Langages et Automates},
  pdfkeywords = {analyse statique, typage, initialisation des variables}
}

\begin{document}

\maketitle

Dans ce TP, nous nous intéressons à \emph{l’analyse statique de programmes}.
Contrairement à l’interprétation, qui exécute un programme sur des valeurs concrètes,
l'analyse statique consiste à raisonner \emph{sans exécuter le programme},
afin de détecter des erreurs potentielles ou des propriétés garanties.

\begin{exercice}[Initialisation des variables]

  Un programme d’exemple est fourni dans le dépôt.
  Il implémente un petit langage impératif, avec variables, expressions arithmétiques
  et structures de contrôle simples.
  Il servira de base pour l’ensemble des exercices.

  
Une première analyse statique est fournie dans le fichier
\lstinline{src/lea/analysis/InitializationAnalysis.java}.
Elle permet de détecter les utilisations de variables \emph{non initialisées}.

Cette analyse parcourt le programme et maintient un ensemble de variables
connues pour être initialisées à chaque point du programme.

\begin{question}

\item Ouvrez le fichier \lstinline{InitializationAnalysis.java}.
  Identifiez la structure de données utilisée pour représenter l’état abstrait
  de l’analyse.

\item Expliquez le rôle de la méthode \lstinline|analyze(Instruction, Set<String>)|.

\item Dans le cas d’une séquence d’instructions,
  expliquez pourquoi l’état abstrait retourné par l’analyse de la première
  instruction est transmis à la seconde.

\item Dans le cas d’une instruction conditionnelle,
  l’analyse calcule l’union de deux ensembles.
  Expliquez précisément pourquoi ce choix est \emph{conservateur}.

\item Donnez un exemple de programme pour lequel cette analyse
  signale une erreur alors que l’exécution concrète ne provoque pas d’erreur.
  Expliquez pourquoi ce comportement est acceptable pour une analyse statique.

\end{question}

\end{exercice}

\begin{exercice}[Écritures inutiles]

On souhaite maintenant adapter l’analyse précédente pour détecter
les variables qui sont \emph{écrites mais jamais lues}.

Une écriture dans une variable est dite inutile si la valeur stockée
n’est jamais utilisée dans une expression ultérieure.

\begin{question}

\item Quelle information supplémentaire doit être suivie par l’analyse
  pour détecter les écritures inutiles ?

\item Modifiez l’état abstrait de l’analyse pour mémoriser :
  \begin{itemize}
    \item les variables écrites ;
    \item les variables lues.
  \end{itemize}

\item Adaptez les méthodes correspondant aux expressions
  pour enregistrer les lectures de variables.

\item À la fin de l’analyse, indiquez comment déterminer
  l’ensemble des variables écrites mais jamais lues.

\item Testez votre analyse sur un programme d’exemple contenant
  des écritures inutiles et vérifiez que celles-ci sont correctement détectées.

\end{question}

\end{exercice}

\begin{exercice}[Typage statique]

On souhaite maintenant effectuer une analyse de \emph{typage statique}
des expressions du langage.

Les variables sont déclarées avec un type explicite (\texttt{int} ou \texttt{bool}).
Le type d’une expression est défini récursivement à partir du type de ses sous-expressions.

\paragraph{Principe}
\begin{itemize}
  \item une constante entière est de type \texttt{int} ;
  \item une constante booléenne est de type \texttt{bool} ;
  \item les opérateurs arithmétiques s’appliquent à des entiers ;
  \item les conditions doivent être de type \texttt{bool}.
\end{itemize}

\begin{question}

\item Implémentez une méthode \lstinline|typeOf(Expression)| qui retourne
  le type d’une expression ou signale une erreur de typage.

\item Expliquez pourquoi cette méthode est naturellement récursive
  sur la structure de l’expression.

\item Modifiez l’analyse pour vérifier que :
  \begin{itemize}
    \item les conditions des instructions conditionnelles sont booléennes ;
    \item les indices de tableaux sont entiers (si le langage les supporte).
  \end{itemize}

\item Testez votre analyse sur des programmes bien typés et mal typés,
  et vérifiez que les erreurs sont correctement détectées.

\end{question}

\end{exercice}

\end{document}
























\ifdefined\CORRECTION
\documentclass[correction]{td}
\else
\documentclass{td}
\fi

\inputexercisepath[src/corrections/TP]{src/exercises}

\usepackage[T1]{fontenc}
\usepackage[hidelinks]{hyperref}
\usepackage{amsmath,amssymb, mathrsfs, stmaryrd}
\newcommand\eqdef{\stackrel{\text{def}}{=}}

\usepackage{algos}
\usepackage{statemachines}
\usepackage{trees}

\codeUE{XLG4IU020}
\intituleUE{Langages et Automates}
\cursus{L2 Informatique}

\author{Matthieu \textsc{Perrin}}

\logo{src/img/logoUN.png}
\institution{Nantes Université}

\typeTP[5]
\title{Introduction à l'analyse statique}

\hypersetup{
  pdftitle  = {Langages et Automates - TP 5 - Introduction à l'analyse statique},
  pdfauthor = {Matthieu Perrin},
  pdfsubject  = {TP de L2 en Langages et Automates},
  pdfkeywords = {analyse statique, AST, variables, types}
}

\begin{document}

\maketitle

Dans les TPs précédents, nous avons construit un interpréteur pour un langage
algorithmique, puis mis en place une gestion robuste des erreurs syntaxiques.
Lorsque le parseur termine sans erreur, il produit un \emph{arbre de syntaxe abstraite}
(AST) représentant le programme.

Le but de ce TP est d'exploiter cet AST pour effectuer une \emph{analyse statique},
c'est-à-dire une analyse du programme \emph{sans l'exécuter}.
Contrairement à l'interprétation, l'analyse statique :
\begin{itemize}
\item ne calcule pas de valeurs ;
\item ne modifie pas la mémoire ;
\item parcourt simplement l'AST pour détecter des problèmes structurels.
\end{itemize}

Les analyses mises en œuvre dans ce TP sont volontairement simples,
mais illustrent des principes fondamentaux utilisés dans les compilateurs réels.

\paragraph{Organisation du traitement}
À partir de ce TP, le flot général devient :
\[
  \text{analyse lexicale} \rightarrow
  \text{analyse syntaxique} \rightarrow
  \text{analyse statique} \rightarrow
  \text{interprétation}
\]
L'interpréteur ne sera exécuté que si l'analyse statique ne signale aucune erreur.

% ==========================================================
\begin{exercice}[Variables non initialisées]
  Une erreur classique dans un programme est l'utilisation d'une variable
  avant toute affectation. Par exemple :
  \begin{lstlisting}
    x <- y + 1;
  \end{lstlisting}
  si \lstinline|y| n'a jamais été initialisée.

  Dans cet exercice, on souhaite détecter ce type d'erreur par une analyse statique.

  \paragraph{Principe}
  L'analyse doit parcourir l'AST en maintenant l'ensemble des variables
  \emph{déjà initialisées}.
  Lorsqu'un identifiant est rencontré dans une expression, il doit appartenir
  à cet ensemble.

  \begin{question}
  \item Créez une nouvelle classe \lstinline|StaticAnalyzer| chargée de l'analyse statique.
    Elle contiendra une liste d'erreurs similaire à celle utilisée dans le TP précédent.

  \item Écrivez une méthode :
    \begin{lstlisting}[language=Java]
      void analyze(Instruction instr, Set<String> initialized)
    \end{lstlisting}
    qui analyse récursivement une instruction.

  \item Complétez l'analyse des instructions suivantes :
    \begin{itemize}
    \item \lstinline|Assignment| : analyser l'expression, puis ajouter la variable affectée ;
    \item \lstinline|Write| : analyser l'expression ;
    \item \lstinline|Sequence| : analyser les instructions dans l'ordre.
    \end{itemize}

  \item Écrivez une méthode similaire pour analyser les expressions :
    \begin{lstlisting}[language=Java]
      void analyze(Expression expr, Set<String> initialized)
    \end{lstlisting}
    qui signale une erreur lorsqu'un identifiant non initialisé est rencontré.

  \item Testez votre analyse avec les programmes suivants et indiquez les erreurs détectées :
    \begin{lstlisting}
      x <- 1;
      écrire(x + y);
    \end{lstlisting}

    \begin{lstlisting}
      y <- 2;
      x <- y + 1;
      écrire(x);
    \end{lstlisting}
  \end{question}

\end{exercice}

% ==========================================================
\begin{exercice}[Analyse et structures de contrôle]
  Les structures conditionnelles et les boucles compliquent l'analyse,
  car certaines instructions peuvent être exécutées \emph{ou non}.

  \paragraph{Conditionnelle}
  Dans une instruction :
  \begin{lstlisting}
    si <cond> alors
      <then>
    sinon
      <else>
    fin si
  \end{lstlisting}
  une variable est garantie initialisée après la conditionnelle
  uniquement si elle l'est dans \emph{les deux branches}.

  \begin{question}
  \item Expliquez pourquoi le programme suivant est problématique :
    \begin{lstlisting}
      si x < 0 alors
        y <- 1;
      fin si
      écrire(y);
    \end{lstlisting}

  \item Dans votre analyse statique, modifiez le traitement de \lstinline|If| :
    \begin{itemize}
    \item analyser la condition ;
    \item analyser séparément les deux branches à partir du même ensemble initial ;
    \item conserver uniquement les variables initialisées dans \emph{les deux branches}.
    \end{itemize}

  \item Testez votre analyse sur des conditionnelles avec et sans \lstinline|sinon|.
  \end{question}

  \paragraph{Boucle \texttt{tant que}}
  Une boucle peut être exécutée zéro fois.
  Par conséquent, aucune variable initialisée uniquement dans le corps
  ne peut être considérée comme garantie après la boucle.

  \begin{question}
  \item Expliquez pourquoi le programme suivant est incorrect :
    \begin{lstlisting}
      tant que x < 10 faire
        y <- x;
      fin tant que
      écrire(y);
    \end{lstlisting}

  \item Modifiez votre analyse pour que les variables initialisées
    dans le corps de la boucle ne soient \emph{pas} ajoutées à l'ensemble
    après la boucle.

  \item Testez votre analyse avec des boucles simples et imbriquées.
  \end{question}

\end{exercice}

% ==========================================================
\begin{exercice}[Analyse plus précise : affectations inutiles]
  Une autre analyse classique consiste à détecter des \emph{affectations inutiles},
  c'est-à-dire des variables qui sont affectées mais jamais utilisées.

  \paragraph{Principe}
  Cette analyse est complémentaire de la précédente :
  \begin{itemize}
  \item on collecte les variables affectées ;
  \item on collecte les variables effectivement lues ;
  \item une variable affectée mais jamais lue peut être signalée.
  \end{itemize}

  \begin{question}
  \item Implémentez une analyse statique qui parcourt l'AST et collecte :
    \begin{itemize}
    \item l'ensemble des variables affectées ;
    \item l'ensemble des variables lues dans des expressions.
    \end{itemize}

  \item À la fin de l'analyse, affichez les variables qui appartiennent
    au premier ensemble mais pas au second.

  \item Testez votre analyse avec les programmes suivants :
    \begin{lstlisting}
      x <- 1;
      y <- 2;
      écrire(x);
    \end{lstlisting}

    \begin{lstlisting}
      x <- 1;
      x <- 2;
      écrire(x);
    \end{lstlisting}

  \item Discutez les limites de cette analyse (faux positifs possibles).
  \end{question}

\end{exercice}

\end{document}
