\ifdefined\CORRECTION
\documentclass[correction]{td}
\else
\documentclass{td}
\fi

\inputexercisepath[src/corrections/TP]{src/exercises}

\usepackage[T1]{fontenc}
\usepackage[hidelinks]{hyperref}
\usepackage{amsmath,amssymb, mathrsfs, stmaryrd}
\newcommand\eqdef{\stackrel{\text{def}}{=}}

\usepackage{algos}
\usepackage{statemachines}
\usepackage{trees}

\codeUE{XLG4IU020}
\intituleUE{Langages et Automates}
\cursus{L2 Informatique}

\author{Matthieu \textsc{Perrin}}

\logo{src/img/logoUN.png}
\institution{Nantes Université}

\typeTP[1]
\title{Introduction à JFlex}

\hypersetup{
  pdftitle  = {Langages et Automates - TP 1 - Introduction à JFlex},
  pdfauthor = {Matthieu Perrin},
  pdfsubject  = {TP de L2 en Langages et Automates},
  pdfkeywords = {automates finis, expressions régulières, analyse lexicale, JFlex}
}

\begin{document}

\maketitle

\emph{JFlex} est un générateur d'analyseurs lexicaux pour Java.
Il prend en entrée un fichier décrivant un \emph{système de définitions rationnelles}
et une \emph{liste d'expressions rationnelles} associées à des actions Java.
En sortie, il produit une classe Java (souvent nommée \texttt{Lexer})
contenant une méthode \texttt{yylex()} capable de découper un flux de caractères
en une suite de \emph{tokens}, c'est-à-dire des sous-chaînes de caractères formant des unités lexicales.

Chaque expression rationnelle est associée à une action Java exécutée à chaque reconnaissance du motif.
Cette action peut être une instruction simple, un bloc d'instructions entre accolades,
ou bien une instruction de retour (\texttt{return}) lorsqu'on veut produire explicitement un objet \texttt{Token}.
Si aucune action n'est précisée, la chaîne reconnue est simplement ignorée.

JFlex est un outil de génération automatique très utilisé pour la phase d'analyse lexicale des compilateurs,
interpréteurs et outils de traitement de texte. Il reprend les principes historiques du programme \texttt{lex},
développé dans les années 70 aux laboratoires Bell d'AT\&T, mais en génère directement du code Java plutôt que du C.

Dans ce TP, nous apprendrons à écrire un fichier \texttt{.flex}, à le transformer en classe Java grâce à \emph{JFlex},
puis à l'utiliser pour reconnaître différents motifs dans une chaîne de caractères. Dans un second temps,
nous verrons comment retourner des objets \texttt{Token} et les utiliser pour colorier un texte.


\begin{exercice}[Mise en place du TP]

  Un exemple de programme utilisant \emph{JFlex} est fourni dans le dépôt.
  Il servira de base aux exercices suivants. Nous allons commencer par le
  télécharger, générer l'analyseur et compiler le projet.

  \begin{question}
  \item Clonez le dépôt :
    \begin{lstlisting}[gobble=4, language=bash]
      git clone https://github.com/LangagesEtAutomates/TP2-Template
      cd TP2-Template
    \end{lstlisting}

  \item Générez l'analyseur et compilez :
    \begin{lstlisting}[gobble=4, language=bash]
      ant compile
    \end{lstlisting}

  \item Expliquez chaque ligne écrite par la génération de l'analyseur dans le terminal. 

  \item Vérifiez qu'un fichier Java a bien été généré dans
    \lstinline{build/lexing/Lexer.java}.
    Vous pouvez ouvrir ce fichier et remarquer la présence d'une méthode
    \lstinline{public Token yylex()}, mais n'essayez pas de le comprendre en détails.

  \item Lancez le programme :
    \begin{lstlisting}[gobble=4, language=bash]
      java -cp "build:lib/*" lexing.Main
    \end{lstlisting}
  \end{question}

  Si vous travaillez sous \emph{Eclipse}, vous pouvez lancer la compilation
  en ouvrant le fichier \texttt{build.xml}, puis en cliquant sur le bouton
  \texttt{Run} de la barre d'outils. Il faut ensuite rafraîchir le projet
  (\texttt{F5} sur sa racine) et exécuter la classe \texttt{lexing.Main}
  par \texttt{Run As → Java Application}.

  \paragraph{Remarque}
  La génération de l'analyseur et la compilation doivent être
  relancées après chaque modification d'un fichier \texttt{.flex}.
  
\end{exercice}

\pagebreak

\begin{exercice}[Reconnaissance de motifs]

  L'objectif de cet exercice est de comprendre comment utiliser
  le lexer généré par JFlex pour produire et afficher un flux de tokens.

  \begin{question}
  \item Ouvrez et lisez le fichier \texttt{src/lexing/Main.java}.
  \end{question}

  \paragraph{Architecture du programme}
  L'entrée du programme est la méthode \lstinline|Main.main|, qui se contente d'appeler
  la méthode \lstinline|Main.readString()|.
  Cette méthode construit un \lstinline|StringReader| à partir du texte d'entrée,
  puis crée un objet \lstinline|lexer| de type \lstinline|Lexer|
  (généré automatiquement à partir du fichier \texttt{lexer.flex}).
  Elle appelle ensuite \lstinline|lexer.yylex()| en boucle, 
  jusqu'à ce que le lexer signale la fin du texte en retournant \lstinline|null|.
  La suite des valeurs non nulles retournées par \lstinline|yylex()|
  constitue le \emph{flux de tokens} produit par le lexer.

  L'architecture du programme est résumée par le diagramme de séquence suivant :
  \lstinline|StringReader| lit l'entrée caractère par caractère,
  \lstinline|Lexer| reconnaît des motifs et les regroupe en tokens,
  et \lstinline|Main| affiche chaque token sur la sortie standard.

  \begin{center}
    \begin{tikzpicture}[x=42mm, y=6mm]
      \draw (0,0) node[draw] (Reader) {\texttt{StringReader}} edge[dashed, ->] +(0,-17);
      \draw (1,0) node[draw] (Lexer)  {\texttt{Lexer}}        edge[dashed, ->] +(0,-17);
      \draw (2,0) node[draw] (Main)   {\texttt{Main}}         edge[dashed, ->] +(0,-17);
      \draw (3,0) node[draw] (Sysout) {\texttt{System.out}}   edge[dashed, ->] +(0,-17);

      \node[draw, fill=black!10, minimum width=3mm, fit={(Main|-0,-1)(Main|-0,-16)},    inner sep=0pt, outer sep=0pt] (main)  {};
      \node[draw, fill=black!10, minimum width=3mm, fit={(Lexer|-0,-2)(Lexer|-0,-7)},   inner sep=0pt, outer sep=0pt] (yylex1) {};
      \node[draw, fill=black!10, minimum width=3mm, fit={(Reader|-0,-3)(Reader|-0,-4)}, inner sep=0pt, outer sep=0pt] (reader1) {};
      \node[draw, fill=black!10, minimum width=3mm, fit={(Reader|-0,-5)(Reader|-0,-6)}, inner sep=0pt, outer sep=0pt] (reader2) {};
      \coordinate (out1) at (Sysout|-0,-8);
      \node[draw, fill=black!10, minimum width=3mm, fit={(Lexer|-0,-9)(Lexer|-0,-14)},    inner sep=0pt, outer sep=0pt] (yylex2) {};
      \node[draw, fill=black!10, minimum width=3mm, fit={(Reader|-0,-10)(Reader|-0,-11)}, inner sep=0pt, outer sep=0pt] (reader3) {};
      \node[draw, fill=black!10, minimum width=3mm, fit={(Reader|-0,-12)(Reader|-0,-13)}, inner sep=0pt, outer sep=0pt] (reader4) {};
      \coordinate (out2) at (Sysout|-0,-15);
      
      \path[-latex] (main.west |- yylex1.north)    edge node[above]{\texttt{yylex()}}            (yylex1.north east) {};
      \path[-latex] (yylex1.south east)            edge node[above]{\texttt{KeyWord("si", 0)}}   (main.west |- yylex1.south) {};
      \path[-latex] (yylex1.west |- reader1.north) edge node[above]{\texttt{read()}}             (reader1.north east) {};
      \path[-latex] (reader1.south east)           edge node[above]{\texttt{`s'}}                (yylex1.west |- reader1.south) {};
      \path[-latex] (yylex1.west |- reader2.north) edge node[above]{\texttt{read()}}             (reader2.north east) {};
      \path[-latex] (reader2.south east)           edge node[above]{\texttt{`i'}}                (yylex1.west |- reader2.south) {};
      \path[-latex] (main.east |- out1)            edge node[above]{\texttt{print(token)}}       (out1) {};
      \path[-latex] (main.west |- yylex2.north)    edge node[above]{\texttt{yylex()}}            (yylex2.north east) {};
      \path[-latex] (yylex2.south east)            edge node[above]{\texttt{Identifier("x", 3)}} (main.west |- yylex2.south) {};
      \path[-latex] (yylex2.west |- reader3.north) edge node[above]{\texttt{read()}}             (reader3.north east) {};
      \path[-latex] (reader3.south east)           edge node[above]{\texttt{` '}}                (yylex2.west |- reader3.south) {};
      \path[-latex] (yylex2.west |- reader4.north) edge node[above]{\texttt{read()}}             (reader4.north east) {};
      \path[-latex] (reader4.south east)           edge node[above]{\texttt{`x'}}                (yylex2.west |- reader4.south) {};
      \path[-latex] (main.east |- out2)            edge node[above]{\texttt{print(token)}}       (out2) {};
    \end{tikzpicture}
  \end{center}

  \paragraph{Représentation des tokens}
  Les valeurs retournées par \texttt{Lexer.yylex()} sont des objets de type \texttt{Token}.
  Chaque token est de la forme \lstinline|token = Type(String text, int offset)|, où
  \begin{itemize}
  \item \texttt{Type} est l'un des types concrets qui implémentent l'interface \texttt{Token}.
    Deux de ces types sont déjà fournis : ce sont des enregistrements (\texttt{record})
    déclarés dans le corps de l’interface :
    \texttt{Token.KeyWord} pour les mots-clés et \texttt{Token.Number} pour les nombres.

    Les \texttt{record}s fournissent automatiquement constructeur, accesseurs et égalité structurelle.
    Le mot-clé \lstinline|sealed| dans la déclaration de l’interface garantit que seules
    les variantes explicitement déclarées dans cette interface (comme \texttt{KeyWord} et 
    \texttt{Number}) peuvent exister.
  \item \lstinline|token.text()| contient le \emph{lexème}, c’est-à-dire la sous-chaîne du texte reconnue par un motif, et
  \item \lstinline|token.offset()| contient la position de début de cette sous-chaîne dans le texte analysé.
  \end{itemize}

  \begin{question}
  \item Ajoutez la ligne suivante dans le corps de l'interface \texttt{Token}
    afin de déclarer un troisième type de tokens, destiné aux identifiants (noms de variables) :
    \begin{lstlisting}[language=java]
      public record Identifier(String text, int offset) implements Token {}
    \end{lstlisting}
    \pagebreak
  \item Ouvrez et lisez le fichier \texttt{src/lexing/lexer.flex}.
  \end{question}

  \paragraph{Structure d'un fichier JFlex}
  La première partie du fichier (avant le premier \lstinline|%%|)
  contient du code Java copié tel quel dans le fichier généré.
  Ici, elle se limite à la déclaration du package.

  La seconde partie (entre les deux \lstinline|%%|)
  contient les \emph{options de génération} et les \emph{déclarations JFlex}.
  Dans cet exemple :
  \begin{itemize}
  \item \texttt{\%public} :
    la classe générée sera publique ;
  \item \texttt{\%class Lexer} :
    nom de la classe Java générée ;
  \item \texttt{\%type Token} :
    indique que la méthode \lstinline|yylex()| retourne un objet de type \texttt{Token} ;
  \item \texttt{\%unicode} :
    prise en charge correcte des caractères UTF-8.
  \item \texttt{\%char} :
    compte le nombre de caractères analysés dans une variable \texttt{yychar}.
  \end{itemize}

  Juste en dessous, on trouve des \emph{définitions rationnelles}, qui donnent un nom
  à une expression rationnelle. Par exemple,
  \lstinline|DIGIT = [0-9]|
  définit le motif nommé \lstinline|DIGIT|. Plus bas dans le fichier,
  le motif qui reconnaît les nombres utilise cette définition en écrivant
  \lstinline|{DIGIT}| à la place de \lstinline|[0-9]|.

  Enfin, la troisième partie (après le second \lstinline|%%|)
  décrit les \emph{règles lexicales} : chaque ligne associe un motif
  (\emph{expression rationnelle}) à une action Java entre accolades.

  Lorsque plusieurs expressions rationnelles peuvent correspondre
  à une position donnée du texte, \emph{JFlex choisit le token de plus grande longueur}.
  S'il existe plusieurs expressions de même longueur,
  \emph{la première règle déclarée dans le fichier est prioritaire}.

  Dans cet exemple :
  \begin{itemize}
  \item les mots \texttt{si} et \texttt{sinon} sont reconnus comme mots-clés
    et retournent un token de type \texttt{Token.KeyWord} ;
  \item les suites non vides de chiffres sont reconnues comme nombres
    et retournent un token de type \texttt{Token.Number} ;
  \item la règle \lstinline|[^]| (tout caractère isolé) joue le rôle de \og rattrapage \fg :
    pour chaque caractère qui ne correspond à aucune autre règle, elle recopie ce caractère
    sur la sortie d'erreur (\texttt{System.err.print(yytext());}).
    Elle ne retourne pas de \texttt{Token} : ces caractères n'apparaissent donc pas
    dans le flux de tokens.
  \end{itemize}

  \begin{question}
  \item Ajoutez de nouvelles règles pour reconnaître les mots-clés
    \lstinline|alors| et \lstinline|fin|, et retourner des tokens de type \texttt{Token.KeyWord}.
  \item Un identifiant de variable est une suite de lettres (majuscules ou minuscules)
    et d'underscores. Ajoutez la règle suivante avant les règles pour les mots-clés,
    puis déplacez-la après celles-ci. Que constatez-vous ?
    \begin{lstlisting}[gobble=4]
      {[A-Za-z_]}+ { return new Token.Identifier(yytext(), (int) yychar); }
    \end{lstlisting}
  \item Ajoutez des règles pour reconnaître les mots
    \lstinline|vrai| et \lstinline|faux| et retourner un token
    de type \texttt{Token.Boolean} à déclarer dans l'interface \texttt{Token}.
  \end{question}

  \paragraph{Motifs d'expressions régulières}
  Les motifs sont des expressions régulières comme pour la commande
  \texttt{grep}. Quelques spécificités sont toutefois à noter :
  \begin{itemize}
  \item Une suite de caractères correspond à la même suite de
    caractères dans le flux d'entrée. On peut placer ces caractères
    (ou une partie seulement)
    entre  guillemets (en particulier, cela est utile si l'on
    inclut un blanc, une tabulation ou un opérateur JFlex
    \verb=[ ] ^ - ? . * + | [ ] $ / { } % < >=. Ces caractères
    perdent leur qualité d'opérateur lorsqu'ils sont précédés 
    de \verb|\|. Une tabulation se code \verb|\t|, le passage
    à la ligne \verb|\n| et \verb|"| par  \verb|\"|.
    Le caractère \verb|\| s'obtient en écrivant \verb|\\|.
    Par exemple, le motif
    \verb|xyz"+\"+"\n| correspond aux chaînes constituées
    des caractères \verb|x y z + " +| et finissant par le caractère
    ``passage à la ligne'' (cette chaîne doit donc se trouver
    en fin de ligne).
  \item Une classe de caractères est indiquée avec des crochets.
    Ainsi \verb|[+a-z0-9]| correspond au caractère \verb|+|, 
    à toute lettre minuscule ou à tout chiffre. 
    Dans \verb|a-z| et \verb|0-9|, le symbole \verb|-|
    a permis de spécifier tous les caractères compris entre deux
    caractères. Si l'on désire ce 
    caractère \verb|-|, il faut le placer en tête de la liste comme
    dans \verb|[-+0-9]|.
    On obtient la liste opposée des caractères spécifiés en ajoutant
    \verb|^| après le \verb|[|. Ainsi, \verb|[^abc]| correspond à tous
    les caractères sauf \verb|a|, \verb|b| et \verb|c|, même
    les caractères de contrôle comme les passages à la ligne.
  \item \verb|.| correspond à un caractère
    sauf le passage à la ligne. Il est donc équivalent à l'expression
    \verb|[^\n]|.
  \item \verb|?| zéro ou une occurrence
    de l'expression qui le précède.
  \item \verb|*| spécifie la répétition
    d'un nombre quelconque de fois d'une expression.
  \item \verb|+| spécifie une répétition
    {\em non vide} d'une expression.
  \item \verb=|= permet d'avoir une alternance
    entre plusieurs motifs.
  \item \verb|(| et \verb|)|
    permettent de grouper des expressions
    comme dans \verb=(ab|cd+)?(ef)*= qui correspond
    à des chaînes comme \verb|abefef|, \verb|efefef|,
    \verb|cdef| ou \verb|cddd| mais pas à
    \verb|abc|, \verb|abcd| ou \verb|abcdef|.
  \item \verb|^| au début du motif indique
    que le motif ne peut être reconnu qu'en début de ligne.
  \item \verb|$| à la fin du motif
    spécifie une reconnaissance en fin de ligne (juste
    avant un caractère ``passage à la ligne'').
  \item \verb|/| permet de spécifier un contexte
    à droite. Ainsi \verb|ab/(cd)| reconnaît les caractères
    \verb|ab| seulement s'ils sont suivis des caractères \verb|cd|.
    En fait, le motif \verb|ab$| est équivalent à \verb|ab/\n|.
  \item \verb|{|{\it nom}\verb|}| utilise la définition de {\it nom}.
  \item \verb|{|$n$\verb|}| (\verb|{|$n$\verb|,|$m$\verb|}|)
    correspond à un motif répété
    $n$ fois (de $n$ à $m$ fois). Ainsi \verb|a{1,5}| correspond à une
    chaîne composée de 1 à 5 \verb|a|.
  \end{itemize}
  
  \begin{question}
    
  \item On veut modifier la règle de reconnaissance des identifiants pour qu'ils suivent la convention classique :
    une lettre ou \verb|_| en premier caractère, puis une suite de lettres,
    chiffres ou \verb|_|. Modifiez la règle des identifiants pour qu'elle reconnaisse
    \og un identificateur composé de majuscules, minuscules, du caractère \verb|_|
    et de chiffres, mais ne commençant pas par un chiffre \fg.
    Par exemple, \verb|x|, \verb|_x12|, \verb|toto_3| doivent être reconnus
    comme identifiants, mais pas \verb|123abc|.
    
  \item Ajoutez une règle permettant de reconnaître les commentaires de ligne,
    commençant par \verb|//| et se terminant en fin de ligne.
    On souhaite ignorer ces commentaires en leur associant
    une action vide \lstinline|{ }|, pour qu'ils ne produisent pas de token ni message d'erreur.
    
  \item Remplacez la règle actuelle des nombres entiers par une règle reconnaissant
    des nombres à virgule flottante positifs, avec le format suivant :
    \begin{itemize}
    \item une partie entière obligatoire ;
    \item une partie décimale optionnelle (séparée par un point) ;
    \item une partie exponentielle optionnelle (\verb|e| ou \verb|E|,
      suivie éventuellement de \verb|+| ou \verb|-|, puis de chiffres).
    \end{itemize}
    Par exemple, \verb|0|, \verb|12.5|, \verb|3e8|, \verb|1.2E-3| doivent être reconnus
    comme nombres. 
    
  \end{question}

\end{exercice}


\begin{exercice}[Coloration syntaxique]

  Le but de cet exercice est d'appliquer l'analyse lexicale à la coloration syntaxique
  dans un éditeur de texte. Pour cela, nous allons modifier l'architecture du programme
  pour que le texte s'affiche dans une fenêtre éditable.

  \begin{question}
  \item Dans la méthode \lstinline|Main.main|, commentez la ligne :
  \begin{lstlisting}[language=Java]
    readString(input);
  \end{lstlisting}
  et décommentez la ligne : 
  \begin{lstlisting}[language=Java]
    // TextEditor.start(input);
  \end{lstlisting}
  \end{question}

  \paragraph{Architecture du programme}
  L'architecture du programme est résumée par le diagramme de séquence suivant.
  
  \begin{center}
    \begin{tikzpicture}[x=40mm, y=6mm]
      \draw (1,9) node[draw] (Lexer)          {\texttt{Lexer}}          edge[dashed, ->] +(0,-9);
      \draw (2,9) node[draw] (Main)           {\texttt{Main}}           edge[dashed, ->] +(0,-9);
      \draw (3,9) node[draw] (TextEditor)     {\texttt{TextEditor}}     edge[dashed, ->] +(0,-9);
      \draw (4,9) node[draw] (StyledDocument) {\texttt{StyledDocument}} edge[dashed, ->] +(0,-9);

      \node[draw, fill=black!10, minimum width=3mm, fit={(Lexer|-0,6)(Lexer|-0,7)}, inner sep=0pt, outer sep=0pt] (yylex1) {};
      \coordinate (sca1) at (StyledDocument|-0,5);
      \node[draw, fill=black!10, minimum width=3mm, fit={(Lexer|-0,3)(Lexer|-0,4)}, inner sep=0pt, outer sep=0pt] (yylex2) {};
      \coordinate (sca2) at (StyledDocument|-0,2);
      \node[draw, fill=black!10, minimum width=3mm, fit={(Main|-0,1)(Main|-0,8)},   inner sep=0pt, outer sep=0pt] (color)  {};

      \path[-latex] (color.west |- yylex1.north) edge node[above]{\texttt{yylex()}}                     (yylex1.north east) {};
      \path[-latex] (yylex1.south west)          edge node[above]{\texttt{Token}}                       (color.west |- yylex1.south) {};
      \path[-latex] (color.east |- sca1)         edge node[above]{\texttt{setCharacterAttributes(...)}} (sca1) {};
      \path[-latex] (color.west |- yylex2.north) edge node[above]{\texttt{yylex()}}                     (yylex2.north east) {};
      \path[-latex] (yylex2.south west)          edge node[above]{\texttt{Token}}                       (color.west |- yylex2.south) {};
      \path[-latex] (color.east |- sca2)         edge node[above]{\texttt{setCharacterAttributes(...)}} (sca2) {};
      \path[-latex] (TextEditor |- color.north)  edge node[below]{\texttt{recolor(this)}}               (color.north east) {};
      \path[-latex] (color.south west)           edge                                                   (TextEditor |- color.south) {};
    \end{tikzpicture}
  \end{center}

  L'éditeur de texte est géré par la classe \texttt{TextEditor}, qui maintient un
  \texttt{StyledDocument}. Vous n'avez ni à comprendre cette classe ni à la modifier. 
  À chaque modification du texte dans l'éditeur, \texttt{TextEditor} appelle
  la méthode statique \texttt{Main.recolor(this)}, qui relit tout le document,
  invoque le lexer pour obtenir un flux de tokens, et applique un style pour chaque token reconnu.

  Pour chaque token produit, \lstinline|recolor()| choisit un style parmi ceux fournis par \lstinline|TextEditor|.
  Dans le code de départ, seuls les mots-clés et les nombres sont colorés,
  via un \texttt{switch} sur le type du token :
  \begin{lstlisting}[language=Java]
    Style style = switch (token) {
      case Token.KeyWord    t -> editor.keyword;
      case Token.Number     t -> editor.number;
      default                 -> editor.defaultStyle;
    };
  \end{lstlisting}

  Finalement, le style choisi est appliqué au segment correspondant du texte
  via un appel à \linebreak \lstinline|document.setCharacterAttributes(offset, length, style, true)|.

  \begin{question}

  \item Pour chaque type de token que vous avez créé dans ce TP
    (par exemple avec \texttt{Token.Identifier} et \texttt{Token.Boolean}),
    ajoutez une branche \texttt{case} au \texttt{switch} de \texttt{Main.recolor()}
    pour colorer également ces tokens, puis supprimez la branche \texttt{default}. 
    
    Des constantes de style \texttt{identifier}, \texttt{bool}, \texttt{comment} et \texttt{string}
    ont déjà été définies pour vous dans la classe \texttt{TextEditor}.
  \end{question}

  On souhaite maintenant reconnaître des littéraux de chaîne entre guillemets
  doubles et leur appliquer une couleur spécifique.

  \begin{question}

  \item Déclarez dans l'interface \texttt{Token}
    un nouveau type de token \texttt{StringLiteral}
    pour les chaînes de caractères.
    Puis, dans \texttt{Main.recolor()}, associez-lui le style
    \lstinline|editor.string| en ajoutant une branche \texttt{case}.

  \item Pour simplifier, on commence sans séquences d'échappement :
    une chaîne est une suite de caractères quelconques sauf \verb|"| et le
    passage à la ligne, entourée de guillemets doubles.

    Proposez un motif JFlex qui reconnaît de telles chaînes
    et ajoutez une règle dans \texttt{lexer.flex} qui
    retourne un \texttt{Token.StringLiteral} avec le texte et l'offset
    appropriés.

  \item Adaptez le motif pour autoriser la séquence de caractères \verb|\"| à l'intérieur d'une chaîne.

    \emph{Indice :} un littéral de chaîne de caractères est composé d'un caractère \verb|"|,
    suivi d'une suite éventuellement vide de :
    \begin{itemize}
    \item soit n'importe quel caractère, sauf un passage à la ligne, \verb|"| ou \verb|\| (\verb|[^"\\]|),
    \item soit le caractère \verb|\| suivi de n'importe quel autre caractère, sauf un passage à la ligne (\verb|\\.|),
    \end{itemize}
    suivie d'un caractère \verb|"|
    
  \end{question}
  
\end{exercice}

\end{document}
